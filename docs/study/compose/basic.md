# Compose

## 개요.
안드로이드에서 선언형 UI모델로 화면을 개발하기 위한 프레임워크.
선언형 UI모델은 화면전체를 개념적으로 재생성하고, 필요한 변경 사항만 적용하는 방식으로 작동한다.
이런 방식으로 상태기반으로 화면 계층 구조를 업데이트할때 복잡성을 방지할 수 있다.

이때 화면 전체를 재생성하는 것은 컴퓨터성능 비용이 많이 필요한게 문제다.
이 비용을 줄이기 위해 컴포즈에서는 특정 시점에 UI의 어떤 부분을 다시그릴지 지능적으로 선택한다.
이는 리컴포지션이라는 개념에서 자세히 설명되어 있다.


## 선언형 UI
기존의 객체지향 UI도구 키트를 사용해서 UI를 개발할 경우,
위젯의 트리를 인스턴스화하여 UI를 초기화 한다.
각 위젯은 상태를 가지고 있으며, 앱 로직이 위젯과 상호작용하기 위한 getter, setter를 노출한다.
> 여기서 위젯은 UI를 구성하는 최소 단위 UI요소를 말한다.

선언형 접근방식으로 UI를 개발하면, 위젯은 상태를 가지지 않는다.
당연히 setter, getter또한 노출할 것이 없다.
사실상 위젯은 개발자에게 객체로 노출되지 않게 된다.
대신 컴포저블 함수(혹은 위젯함수)의 파라미터로 UI를 업데이트한다.
> 여기서 컴포저블 함수는 조립가능한 함수라고 보면 된다.
> Jetpack compose에서 @Composable 어노테이션으로 컴포저블 함수를 정의하며,
> 실제로 안드로이드 시스템은
> 이 컴포저블, 즉 조립가능한 함수들을 호출하여, 실질적으로 위젯을 그리게 된다.

이는 아키텍쳐 패턴으로 부터 상태를 공급받아 위젯함수를 호출하는 형태로 
상태를 단방향으로 구독하여 화면 계층을 그리는 형태로 개발할 수 있게 된다.
(실무에서는 viewModel에서 발행한 uiState를 구독하여 컴포저블 함수를 호출한다.)


## 재구성(리컴포지션)
사용자가 UI와 상호작용을 할때는 onClick과 같은 이벤트를 발생시킨다.
이런 상호작용 이벤트를 앱 로직에 전달해서 앱의 상태를 변경해야 한다.
(실무에서 뷰모델에 uiIntent를 전달하는 형태로 구현된다.)
상태가 변경되면, 앱로직에서 새로운 상태를 발행하고,
화면은 새로 발행된 상태로 위젯함수를 호출하여 UI요소를 새로 그린다. 
이 과정을 재구성(리컴포지션) 이라 한다.

명령형 UI모델에서 위젯을 변경하기 위해선
위젯의 setter를 호출하여 위젯 내부의 상태를 변경한다.
Compose에서는 새 데이터를 사용해서, 컴포저블 함수를 호출한다.
이렇게 되면 함수가 호출되면서 해당 범위의 위젯이 재구성된다.
이 과정에서 입력이 변경된 컴포저블 함수만 다시 호출되며,
입력이 변경되지 않은 함수는 건너뜀으로서 효율적인 화면 재구성이 일어난다.

컴포저블 함수의 입력은 슬롯테이블에 저장된다.
슬롯테이블에 저장된 내용은 리컴포지션때마다 슬롯테이블에 저장된 값과 비교하여 
호출할 컴포지션 함수의 범위를 결정한다.











