# data모듈
[data-room-adapter](/core/data-room-adapter)

## 관계 모델링과 제약의 명시
초기 생각:
> 도메인은 언제든 확장되거나 변경될 수 있으니,  
> 마이그레이션 리스크를 없애기 위해 모든 관계를 M:N으로 설계하자.

그러나 이 방식은 다음과 같은 문제를 초래:
- 제약이 느슨해지며 도메인의 의미가 약화되고,
- 모델 간의 의도가 불분명해져 테스트와 리팩토링이 어려워졌으며,
- 오히려 마이그레이션 시점에서 더 큰 예측 불가능성과 혼란을 초래.

이 문제를 피하기 위해 다음의 원칙을 적용:
- 의도된 제약을 명시적으로 모델링
  - 도메인 상 1:N 관계라면 실제 DB에서도 1:N으로 구현하여, 데이터 구조 자체가 의미를 가지도록 설계합니다.
- 변경 가능한 관계보다, 의미가 명확한 구조를 우선
  - 확장성은 중요하지만, 그보다 중요한 것은 현재의 도메인 요구사항에 대한 정확한 표현입니다.
- 마이그레이션은 회피할 대상이 아니라, 설계의 일부
  - 테스트 가능한 구조를 바탕으로 하면, 관계 변경 역시 안전하게 수행 가능하며 도메인의 진화를 기록하는 과정이 됩니다.

## @Relation 보다 @DatabaseView
Room의 @Relation은 쿼리 로직이 숨겨짐.
- 쿼리의 실행이(ORDER, LIMIT, 필터) 코드에 보이지 않음 
  - 유지보수 입장에서는 데이터 관계/흐름이 불투명.
  - ~~내부적으로는 서브쿼리로 보이며, 성능 예측하기도 어려움.~~
  - 정확히는 N+1 개의 개별 SELECT를 Room이 실행하므로 성능 예측이 힘듬.
- 불필요한 쿼리의 증가.
  - @Relation 객체로 만들어 사용하니, 필요한 조건에 따라 튜닝이 힘들어, 
  - 별개의 Join된 쿼리를 추가로 만들어야함. 이 과정에서, 관리가 필요한 쿼리가 계속 증가됨.
- 차라리 @DatabaseView를 사용하면, 
  - Join된 DTO를 만들면, 더 범용적으로 쓸 수 있으며,
  - @Relation과 같은 1:N 관계의 객체를 만들어 쓰고 싶으면,
  - List<DTO>목록에서도 kotlin 컬렉션 함수의 groupBy로 만들 수 있음.
    - 심지어 DTO따로, 도메인 데이터인 구조이므로, 
    - 실제 1:N관계의 객체는 이미 도메인 데이터로 정의되어 있으므로,
    - 따로 데이터를 정의하기 위한 고민을 할 필요도 없다. 
