# data모듈
[data-room-adapter](/core/data-room-adapter)

## 관계 모델링과 제약의 명시
초기 생각:
> 도메인은 언제든 확장되거나 변경될 수 있으니,  
> 마이그레이션 리스크를 없애기 위해 모든 관계를 M:N으로 설계하자.

그러나 이 방식은 다음과 같은 문제를 초래:
- 제약이 느슨해지며 도메인의 의미가 약화되고,
- 모델 간의 의도가 불분명해져 테스트와 리팩토링이 어려워졌으며,
- 오히려 마이그레이션 시점에서 더 큰 예측 불가능성과 혼란을 초래.

이 문제를 피하기 위해 다음의 원칙을 적용:
- 의도된 제약을 명시적으로 모델링
  - 도메인 상 1:N 관계라면 실제 DB에서도 1:N으로 구현하여, 데이터 구조 자체가 의미를 가지도록 설계합니다.
- 변경 가능한 관계보다, 의미가 명확한 구조를 우선
  - 확장성은 중요하지만, 그보다 중요한 것은 현재의 도메인 요구사항에 대한 정확한 표현입니다.
- 마이그레이션은 회피할 대상이 아니라, 설계의 일부
  - 테스트 가능한 구조를 바탕으로 하면, 관계 변경 역시 안전하게 수행 가능하며 도메인의 진화를 기록하는 과정이 됩니다.

## @Relation 보다 @DatabaseView
Room의 @Relation은 쿼리 로직이 숨겨짐.
- 쿼리의 실행이(ORDER, LIMIT, 필터) 코드에 보이지 않음 
  - 유지보수 입장에서는 데이터 관계/흐름이 불투명.
  - ~~내부적으로는 서브쿼리로 보이며, 성능 예측하기도 어려움.~~
  - 정확히는 N+1 개의 개별 SELECT를 Room이 실행하므로 성능 예측이 힘듬.
- 불필요한 쿼리의 증가.
  - @Relation 객체로 만들어 사용하니, 필요한 조건에 따라 튜닝이 힘들어, 
  - 별개의 Join된 쿼리를 추가로 만들어야함. 이 과정에서, 관리가 필요한 쿼리가 계속 증가됨.
- 차라리 @DatabaseView를 사용하면, 
  - Join된 DTO를 만들면, 더 범용적으로 쓸 수 있으며,
  - @Relation과 같은 1:N 관계의 객체를 만들어 쓰고 싶으면,
  - List<DTO>목록에서도 kotlin 컬렉션 함수의 groupBy로 만들 수 있음.
    - 심지어 DTO따로, 도메인 데이터인 구조이므로, 
    - 실제 1:N관계의 객체는 이미 도메인 데이터로 정의되어 있으므로,
    - 따로 데이터를 정의하기 위한 고민을 할 필요도 없다. 


## uuid + id pkey 를 쓰는 이유

### 두 키를 모두 쓰는 이유
- `uuid`가 있는데도 auto increment `id`를 PK로 둔 이유는 **성능** 때문이다.
- SQLite의 인덱싱은 **B-Tree 기반**이라, `uuid`(문자열)를 키로 사용해 join하면 성능 저하가 발생할 수 있다.
- 따라서, 내부 조인/참조에는 `id`를 사용하고, 도메인/외부 세계에는 `uuid`를 사용한다.

### id만 쓰면 안 되는 이유
- `id`는 **DB 내부 관리용 키**라서 도메인 레벨에서 의미가 없다.
- 도메인에서 유일성을 보장하기 위해서는 **`uuid`를 별도로 두는 게 맞다.**
- 추후 클라우드/멀티 디바이스 확장 시에도 유용하다.

### 복합키 혼동 가능성
- `id`와 `uuid`가 함께 있으면 복합키처럼 보일 수 있으나,
  - 둘 다 `UNIQUE` 속성을 갖기 때문에 충돌은 없다.
  - `id`는 data 모듈 안에서만 쓰이고 바깥으로 노출되지 않으므로 오염 위험도 없다.

### uuid를 PK로 쓰지 않은 이유
- `uuid`를 PK로 승격하면 join 성능 문제가 발생한다.
- `uuid`를 **BLOB(16바이트)**으로 저장하면 문자열보다 성능이 나아질 수 있지만,
  - DB 브라우저 도구에서 열었을 때 디버깅이 매우 불편해진다.
  - 
### 최종 결론 (구조)
auto increment pkey = id:Int //내부 성능 최적화용(Join, FK)  
domain identifier id = uuid:String //도메인/동기화용, 외부 노출 식별자.
- `id`는 **성능이 필요한 작업 (예: Join)**에서만 사용하고 data 모듈 바깥에는 노출하지 않는다.
- `uuid`는 **리모트와 동기화**할 때 사용한다.


# @Upsert
room에서 insert or update를 해주는 어노테이션이다.  
편리해보이지만, conflict발생시, 기존 중복 row를 삭제하고,   
새 row를 추가하므로, 예상치 못한 덮어쓰는 일이 발생하므로,  
사용을 지양하는 것이 옳다고 본다.


# DataResult를 사용한 오류 핸들링.
throw 를 통한 전파는 의도치 않은 오류 전파가 일어난다.
가급적 오류는 모듈 안에서 끊고 가는게 더 깔끔함.
DomainResult.Success, DomainResult.Failure로 나누어 
성공 실패에 대한 결과 리턴을 나누는 방식을 도입하고,
패턴화 된 오류 처리가 가능해졌다.

DomainResult.Failure의 에러코드는 데이터 오류도 같이 담고 있어서, 
데이터 모듈의 RepositoryPortAdapter에도 일부 리턴형에 적용을 했지만,
사실 Domain오류 코드에는 불필요한 예외가 너무 많으며,
Data에서만 담아서 처리한 오류코드가 도메인오류코드 까지 전파되어,
오류코드 sealed interface가 매우 지저분해 지는 상황이 나왔다.

따라서, DataResult.Success, DataResult.Failure를 나누어,
데이터 모듈에서의 결과 처리는 이 범위에서 끝낸다.
물론 맵핑이 많아 지는건 사실이다.
하지만 한 결과 상태가 너무 많은 책임을 지는것 보다는
이렇게 맵핑을 통해서 전파되는게 더 깔끔하다.



