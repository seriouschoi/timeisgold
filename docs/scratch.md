# Scratch board.

### turbine
turbine은 flow의 값을 확실히 통제할 수있을때만 쓰는게 좋을것 같아.
예를 들면 room + flow조합일때, room에서 오는 초기값을 알 수가 없으므로,
테스트에서 굳이 turbine을 쓰는게 좋은 방법은 아닐 수 있다.
물론 순차적으로 오는 queue를 테스트하고 싶을때는 유용할 수도 있다.

그냥 잘 저장되고 잘 불러오는지 테스트 목적이면...
그냥 flow의 first함수를 호출하는게 나을 수도.

### uuid + id pkey

uuid가 무조건 unique로 나올거라는 신뢰를 못해서,
auto increment되는 pkey를 쓰는 구조를 썼는데..
또 생각해보니 join성능도 빠르겠구나..
근데 이건 인덱싱 하면...uuid문자열도 빠르지 않나..

아무튼 신뢰 + 성능때문에 autoInc되는 id를 따로 두고,
추후 클라우드 욕심 때문에 uuid 유니크 키 컬럼도 따로 두었는데..
근데 사실상 pkey가 두개인 구조가 되서 맛탱이 간 구조같다.
일단 update칠때 코드가 더러워진다.
사실 뭐랄까... 그냥 나 이런 구조도 짤줄 안다고 자랑할려고 짠 구조같은데 오히려 뭔가 잘못된 느낌...

사실 생각해보면 데이터 크기도 얼마 안되는데..성능은 무슨놈의 성능.

근데 UUID를 BLOB으로 pkey로 저장하고, 
디버깅용 컬럼을 두는건 어떨까?
공통 스키마요소로 인터페이스화 시켜놓으면...
..아니다 뭔가 공통으로 두는것 치고 잘되는 꼬라지를 못봤는데..
이게 눈에 안들어와 추상클래스로 하면...

지금이 가장 나을수도...
물론 uuid를 그냥 pkey로 승격하고, 인덱싱을 잘하는것이 가장 나을 수도 있다.
Room이 어쩄든 SQLite기반일텐데,
인덱싱을 해도 B Tree기반이라.. 길면 비용이 커질걸.
지금이 가장 나은걸수도 있겠다.

auto increment pkey = id:Int
domain identifier id = uuid:String
이 구조로 해서 pkey는 성능이 필요한 작업시 쓰는거지.
보통 Join..
uuid는 동기화때 쓰는거고.(data-adapter-room) 같은 모듈의 바깥에서만 쓰는거지.