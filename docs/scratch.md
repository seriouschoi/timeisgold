# Scratch board.

### turbine
turbine은 flow의 값을 확실히 통제할 수있을때만 쓰는게 좋을것 같아.
예를 들면 room + flow조합일때, room에서 오는 초기값을 알 수가 없으므로,
테스트에서 굳이 turbine을 쓰는게 좋은 방법은 아닐 수 있다.
물론 순차적으로 오는 queue를 테스트하고 싶을때는 유용할 수도 있다.

그냥 잘 저장되고 잘 불러오는지 테스트 목적이면...
그냥 flow의 first함수를 호출하는게 나을 수도.

### uuid + id pkey

uuid가 무조건 unique로 나올거라는 신뢰를 못해서,
auto increment되는 pkey를 쓰는 구조를 썼는데..
또 생각해보니 join성능도 빠르겠구나..
근데 이건 인덱싱 하면...uuid문자열도 빠르지 않나..

아무튼 신뢰 + 성능때문에 autoInc되는 id를 따로 두고,
추후 클라우드 욕심 때문에 uuid 유니크 키 컬럼도 따로 두었는데..
근데 사실상 pkey가 두개인 구조가 되서 맛탱이 간 구조같다.
일단 update칠때 코드가 더러워진다.
사실 뭐랄까... 그냥 나 이런 구조도 짤줄 안다고 자랑할려고 짠 구조같은데 오히려 뭔가 잘못된 느낌...

사실 생각해보면 데이터 크기도 얼마 안되는데..성능은 무슨놈의 성능.

근데 UUID를 BLOB으로 pkey로 저장하고, 
디버깅용 컬럼을 두는건 어떨까?
공통 스키마요소로 인터페이스화 시켜놓으면...
..아니다 뭔가 공통으로 두는것 치고 잘되는 꼬라지를 못봤는데..
이게 눈에 안들어와 추상클래스로 하면...

지금이 가장 나을수도...
물론 uuid를 그냥 pkey로 승격하고, 인덱싱을 잘하는것이 가장 나을 수도 있다.
Room이 어쩄든 SQLite기반일텐데,
인덱싱을 해도 B Tree기반이라.. 길면 비용이 커질걸.
지금이 가장 나은걸수도 있겠다.

auto increment pkey = id:Int
domain identifier id = uuid:String
이 구조로 해서 pkey는 성능이 필요한 작업시 쓰는거지.
보통 Join..
uuid는 동기화때 쓰는거고.(data-adapter-room) 같은 모듈의 바깥에서만 쓰는거지.

### TBD(Trunk Based Dev)

운영이름에 맞추게 되는 git flow와 달리,
실제 개발작업에 맞춘 브랜치 그룹명을 쓴다.
기능이면, feature/*
버그 수정이면, fix/*
뭐 빌드 깨진거 복구면, build/* 로 해도 되지 않을까? 물론 팀의 규칙이 있으면 그걸 따르고,
중요한건, main/master에서 갈라져 나온 브랜치를 최대한 빨리 합칠 수 있게 한다.
그런걸 보면, 브랜치 그룹명이 실제 작업과 매칭이 되는것도 이런 이유 때문인것 같다.
팀 작업이라면, spike에서 실험하고, 완료되면, main에서 feature/를 따서 빨리 개발하고,
main에 머지한다. 
시행착오 커밋은 안남기고, 실제 작업한 커밋만 남겠지.
이 과정에서 git의 워크트리 기능을 쓰면, 더 좋다.
spike를 작업한 워크트리를 참고하며, feature에 시행착오 없이 붙인다.
이 과정에서 팀은 코드 뿐이 아니라, 커밋기록에도 시행착오가 안남곘지.
물론 git flow에서도 같이 쓰면 좋은 규칙이다.

### Domain Drive...

도메인 주도로 시작을 했는데도 리팩토링이 계속 나온다.
지금 생각해보면 그냥 화면 먼저 빼고...화면에 요청할걸 뷰모델에서 마구잡이로 usecase만들어 날리고..
usecase에 맞춰서 데이터 정의하고, 만드는게 시행착오가 적었을까..

도메인 주도 개발이 허상일 수도 있을것 같다... 지금 생각해보면..

이게..주도 개발이라는 표현이 어떤 의미일지 좀 생각을 해봐야 하는건데..
주도 개발 = 그걸 먼저 한다 라고 생각하거든..
테스트주도 개발은 테스트를 만들고 테스트가 동작되기 위해 개발을 구현하는것이고..
도메인주도 개발은 도메인을 먼저 정의하고 도메인 인터페이스를 구현하면서 개발을 하는거고..
근데 주도 개발이라는 표현 자체가 의미가 없는것 같아. 그냥 구조만 중요할 뿐...

결국 주도 개발은 그때그때 꺼내 쓰는 기법인거야.
테스트를 만들다가 기능(도메인)이 생각나서 테스트를 만들고 거기에 맞춰서 도메인이 추가되고, 어댑터도 변경되는거고..
화면(기능)만들다가 도메인이 떠오르면 도메인이 또 추가되는거고..
무조건 도메인 주도는 없는거야.
그냥 불필요한 결합을 줄이기 위한 구조가 있는거고, 그 구조안에서 기능을 구현하는 기법일 뿐.

