# 관계와 계약 확정

## 작업의 방향.
VO, Entity 리팩토링은 이미 끝났고,  
이제 구조가 크게 바뀔 일은 많지 않을 것으로 본다.

문제는 여기까지 오면서 사이드 이펙트가 너무 커졌다는 점이다.  
앱을 계속 실행해서 손으로 테스트하는 방식으로는 더 이상 버티기 어렵다.

지금부터의 방향은 이걸로 잡는다.

1. 각 모듈, 각 계층 사이의 관계를 "계약" 관점에서 다시 본다
    - 어떤 입력을 받는지
    - 어떤 출력을 내보내는지
    - 어떤 에러를 어떤 형태로 전달하는지
    - 어떤 상태/불변조건을 보장해야 하는지

2. 이 계약을 코드 상에서 명시한다
    - 인터페이스, usecase 시그니처, 반환 타입, 에러 타입
    - 도메인 규칙을 주석이나 테스트 이름 수준까지 적어둔다

3. 계약을 기준으로 테스트를 작성한다
    - 구현체 내부 동작을 검증하기보다,  
      "계약을 만족하는지"를 보는 테스트를 만든다

4. 테스트를 통과하는 방향으로 구현을 정리한다
    - 기존 구현이 애매하면, 일단 구현은 무시하고 계약부터 고정한다
    - 그 다음 구현을 계약에 맞게 고쳐 나간다

요약하면:

- 지금까지는 구현을 먼저 바꾸고, 눈으로 확인하면서 따라갔다
- 이제부터는  
  구현보다 계약을 먼저 확정하고,  
  계약에 맞게 구현을 맞추고,  
  그 계약을 테스트로 자동 검증하는 단계로 넘어간다

- 뷰모델의 MVI흐름에서 자꾸 문제가 생기는것 같아서 테스트를 만들것이다.
  
## DI의 정리.
테스트를 만들면서, 뷰모델 내부에서 초기화되는 로직으로 인해, 호출자 입장에서,
불분명해 지는 로직이 있었다.
대표적으로 요일 페이저에서 현재 요일을 기본 선택되게 만들었는데,
이걸 뷰 모델 내부에 구현해서, 테스트에서 현재요일을 주입할 수가 없게 되었다.

이를 개선하기 위해서 현재 요일을 외부에서 주입을 하여야 하며,
많은 방법들이 있지만, 뷰모델의 생성자에 현재요일 공급자를 주입하는 형태가 가장 적절해보인다.

이 현재요일 공급자를 모킹하면, 테스트도 용이해진다.

그럼 di를 어디에 할 것인가?
기존 di를 정의한 위치인 repo-adapter 모듈은 dapter를 internal로 만들어서, 외부 노출을 막고,
모듈내에서 주입하여 불필요한 의존이 생기는 사고를 막는 효과가 있었다.
고로 adapter모듈 내부의 di는 근거가 충분하다.

하지만 이런 단순한 기능을 위해 현재 요일 공급자 모듈을 만드는건 좀 우습다.
:core:common-util정도로 봐도 무방하다고 본다.
그렇다면 여기세 공급자를 정의하고, 공급자의 주입은 어디에 하는게 좋을지 고민해봐야 한다.

후보는 이걸 사용할 피쳐모듈, 앱 모듈, 그리고 전용 di모듈, 그리고 이게 정의된 유틸 모듈이 있는데,
앱 모듈이 가장 적절하다고 본다.
현재 요일은 앱 전역적으로 쓰는 개념이기 때문에 각 피쳐모듈마다 현재요일이 달라지면 문제가 될 것이고,
어댑터 모듈이면 몰라도, 유틸모듈에서 의존성을 주입하면, 모듈 구조에서 가독성이 떨어진다.
전용 di모듈이 그럴싸해보이지만, 한 앱이 한 di모듈을 사용한다면,
앱의 variant가 늘어나게 될경우, 이상적으로 구현한다면, variant마다 앱모듈을 만들어야 하고,
앱모듈 마다 di를 추가하게 되는데, 이는 관리요소가 폭증된다.
고로, 앱모듈에 di를 구성하는게 옳다고 본다.

## 테스트의 필요성.
Flow를 쓰다보면 자연스럽게 사용자의 입력을 폼으로 제한하기 보다,
사용자의 입력을 최대한 열어주고 상태기반으로 처리하게 된다.
이렇게 사용자에게 많은걸 열어주는 UX를 만들고나면, 입력조합폭이 기하급수 적으로 늘어나므로,
의도되지 않은 상태전이를 일일히 손으로 재현할수 없으므로, 테스트를 사용한 개발이 편할 수 밖에 없다.