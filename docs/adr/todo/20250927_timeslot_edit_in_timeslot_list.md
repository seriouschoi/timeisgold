## 슬롯 추가/슬롯 편집시, 슬롯 목록에서 처리.(굳이 화면을 쪼개지 않도록)

## 이미 추가된 슬롯을 누르면, 하단 scaffold에 슬롯 편집 화면이 뜬다.
제목은 그냥 텍스트 필드 입력.
시간 입력을 timepicker를 쓰면 오히려 불편할 듯.
차라리 직접 입력으로 하자.
시는 0~23, 분은 0~59
입력이 될때마다 slot list가 갱신되고,
만약 입력된 값이 올바르지 않으면, 입력필드를 붉은색으로 표시.

## 타임 슬라이스 영역을 터치하면, 슬롯 추가.
타임 슬라이스 누르면 하단에 슬롯 편집 뷰 추가하기 구현.

## 타임 슬롯 목록의 뷰모델이 복잡하므로, stateHolder로 정리.
우선 uiState를 보고 분리할 수 있는걸 찾아보자.
일단..이걸 sealed class로 만들어놨구나.. ㅋㅋㅋ
큰맘 먹고... 정리하자.
아니 버리는 속성이 왜이리 많냐..
로딩 타입도 합침.

불러오기가 완료됐는데, 로딩이나 에러를 안끌까봐 이렇게 만들었었구나.
누락이 안되게 할려고..

routineState는 어떻게 관리할까?

## 기존 타임 슬롯 편집 기능.
컴포저블에서 드래그하고,
드래그중인 정보를 intent에 담아서 뷰모델에 전달.
뷰 모델은 전달받은 값으로 상태를 갱신하여, 드래그를 표현함.

어..타임슬롯 드래그할때 policy일부를 써야해서..
드래그해서 갱신되는 걸 uiState를 갱신했는데..
지금보니.. policy에서 필요한 정보도 ui의 상태니깐..
uiState에 policy의 정책 값을 담아서 보내고..
드래그중인 이벤트들은 view에서 끝내는게 맞을것 같은데..?

드래그를 전부 뷰에서 처리한다.
드래그가 완료되면, 인텐트를 발행한다.
(인텐트 폭주 방지)

목록뷰는 state를 받아서 보여준다.
state는 내부에서 rememberUpdatedState로 감싼다.
감싼 이유가 뭐더라..?
드래그가 안되는 문제를 해결하려고 했구나..

## 드래그로 인해 바뀌는 UX를 뷰모델에서 처리했던 이유.
1. 자정이 넘어가는 이벤트는 둘로 쪼개서 표현함.
   1. 이건 사실 policy가 아니라 ux임. 
2. 슬롯 최소 길이, 제목 등 정책에 드래그에 맞는 동작만 허용.
   1. GetTimeSlotPolicyValidUseCase.

현재 구조.
1. 목록 뷰에서 드래그 시작
2. 드래그 중인 이벤트를 뷰모델에 인텐트로 전달.
3. 뷰모델은 인텐트에 맞춰서 목록 상태 업데이트.
4. 업데이트 과정에서 정책 usecase체크.
5. 드래그 완료되면, 업데이트 usecase실행.

문제점.
1. 드래그 관련된 처리로 인해, 뷰모델의 책임이 너무 많아짐.
2. 목록을 터치해서 수정하거나, 빈 공간을 터치해서 해당 시간대에 아이템을 추가하는 등의 동작까지 추가되면, 
   1. 책임이 더욱 커짐.
3. 이를 개선하기 위해, 드래그 관련된 이벤트를 stateHolder로 빼면, 
   1. stateHolder에서 usecaes 도메인 로직에 접근하게됨. 비지니스 로직 접근이 복잡해짐.
   2. stateHolder가 도메인과 결합됨.
   3. 뭐 일단 지금 보면.. 드래그할때 필요한 정책에 필요한걸 데이터로 정의해서 상태에 전달할까..
      1. 나름 드래그 할때, 판단 기준같은것도 현재 화면의 상태같은거 아닌가..?
   4. 근데 애초에 stateHolder의 역할이 이게 맞나? 그냥 화면 인터렉션이니 역시 화면에..?
4. 그래서 composable에서 한다면..
   1. 뭐 stateHolder에 하는것과 비슷한 문제들이 생기는것 같은데..
 

