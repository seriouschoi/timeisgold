## 슬롯 추가/슬롯 편집시, 슬롯 목록에서 처리.(굳이 화면을 쪼개지 않도록)

## 이미 추가된 슬롯을 누르면, 하단 scaffold에 슬롯 편집 화면이 뜬다.
제목은 그냥 텍스트 필드 입력.
시간 입력을 timepicker를 쓰면 오히려 불편할 듯.
차라리 직접 입력으로 하자.
시는 0~23, 분은 0~59
입력이 될때마다 slot list가 갱신되고,
~~만약 입력된 값이 올바르지 않으면, 입력필드를 붉은색으로 표시.~~

## 타임 슬라이스 영역을 터치하면, 슬롯 추가. -> 완료.
타임 슬라이스 누르면 하단에 슬롯 편집 뷰 추가하기 구현.

타임슬라이스 뷰위에 타임슬롯뷰가 덮어씌워져 있는데...
타임 슬롯뷰는 아래의 코드로 제스쳐를 처리하고 있고..
```kotlin
 pointerInput(key) {
    awaitEachGesture {
        ...
    }
}
```
덕분에 타임슬라이스 뷰가 터치가 안됨.
[x] 타임 슬롯뷰의 터치 이벤트를 또 튜닝해야함..


## 타임 슬롯 목록의 뷰모델이 복잡하므로, stateHolder로 정리. -> 완료.
우선 uiState를 보고 분리할 수 있는걸 찾아보자.
sealed class로 나눠놓은 uiState를 정리.
아마도 로딩이 완료되었는데, 로딩 메시지를 null로 채우는 처리를 누락할걸 우려했던것 같다.

## 기존 타임 슬롯 편집 기능. -> 완료.
컴포저블에서 드래그하고,
드래그중인 정보를 intent에 담아서 뷰모델에 전달.
뷰 모델은 전달받은 값으로 상태를 갱신하여, 드래그를 표현함.

### 현재 구조.
1. 목록 뷰에서 드래그 시작
2. 드래그 중인 이벤트를 뷰모델에 인텐트로 전달.
3. 뷰모델은 인텐트에 맞춰서 목록 상태 업데이트.
4. 업데이트 과정에서 정책 usecase체크.
5. 드래그 완료되면, 업데이트 usecase실행.

### 개선안.
1. 드래그 관련된 처리로 인해, 뷰모델의 책임이 너무 많아짐.
2. 목록을 터치해서 수정하거나, 빈 공간을 터치해서 해당 시간대에 아이템을 추가하는 등의 동작까지 추가되면, 
   1. 책임이 더욱 커짐.
3. 그렇다면, 드래그로 인한 목록을 계산하는 기능을 별개의 클래스로 분리하여 주입.
   1. 해당 클래스에서 필요한 useCase등을 주입.

## 타임슬롯 드래그 할때, 기존 timeSlotEdit이 표시된 상태인 경우, editView도 함께 갱신. -> 완료.


# 타임 슬라이스 뷰에 현재 시간 마크 표시.

# 타임슬롯 에딧 뷰 상단에 삭제 버튼 추가. -> 완료

# 타임 슬롯 에딧 뷰의 시간 선택 범위 제약설정하기.


# 슬롯 에딧 모드일때, 슬롯을 탭하면, 에딧모드가 닫히는게 더 자연스러울듯..