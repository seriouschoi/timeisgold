# 타임 슬롯 목록에서 타임 슬롯을 드래그하여 시간을 변경한다.

1. [x] 상단 하단에 핸들 추가해서 잡고 늘리면, 시간 늘어나게 만들자.
2. [x] 슬롯을 드래그 할때 시간 텍스트 실시간 갱신.
   1. [x] 갱신하면서, 뷰크기 조정을 차라리 실시간 시간 기반으로.
3. [x] 롱탭을 헀을때만 스크롤 되게 만들자.

## [x] 뷰에 상태로 가지고 있는 요소들을 인텐트와 상태로 개선.
1. 이슈
   1. 뷰모델의 상태와 뷰에서 드래그중 임시로 들고 있는 상태의 중첩에 대한 정책을 처리하는 코드로 인해,
   2. 컴포저블 함수가 매우 지저분해진 상태. 차라리 드래그하면서 갱신되는동작을 인텐츠로 확실히 정의하고,
   3. 뷰모델에서 인텐트를 받아서, 뷰를 갱신해주자.
   4. 이렇게 만드는게 유효성을 체크할때도 더 유리할 것이다.
   5. 해당 인텐트는 드롭할때 발생하는 인텐트와 분리하여, 드래그 중일때 가벼운 동작으로 분리되서 처리할 수 있게 한다.
2. 자정을 걸친 타임슬롯을 어떻게 처리할까..?
   1. 지금 현재는 이걸 뷰에서 처리하고 있다. 뷰모델은 그냥 타임 슬롯을 들고 있고,
   2. 자정을 쪼개는 처리는 뷰에서 하고 있다.
   3. 이 시점에서 uiState는 ui를 직관적으로 보여주지 못하는 상태가 된것이다.
   4. 그러니깐 차라리 뷰모델에서 쪼개자. 다만 드래그할때 직관적이어야 하므로, **네거티브 미닛**과, **오버 미닛**을 허용해야 한다.
   5. 음...근데 네거티브 미닛은 상태를 표현하기 위한 분이고, 실제 엔티티 시간도 따로 있어야지...(근데 이건 시간 텍스트속성으로 정의하자.)
3. 뷰모델에서 처리하게 바꿨는데...드래그가 안되는데..?
   1. 이유가 뭘까.. 새로 드래그 한 시간을 intent로 발행하고..
   2. 뷰모델의 상태는 인텐트 플로우를 관찰하여, 인텐트 플로우에서 발행된 드래그 이벤트에 맞춰서 상태를 갱신한다.
   3. 근데 아마 갱신되는 주기와 별개로 드래그 이벤트가 계속 일어나서 그런가..?
   4. 아..그게 아니고.. PointerInputEventHandler 가..들고 있는 시간이 예전 시간이라 그럴걸..
   5. 왜냐면 저 람다는 생성당시의 slotItem을 참조하고 있을꺼야. 핸들러 생성 당시의 슬롯아이템을..
   6. 그래서 rememberUpdatedState를 사용.
7. 드래그 하다가 갑자기 시작분과 종료 분이 같은 시간이 되는데..
   8. 로그를 보니 드래그로 자정을 넘길때 나오는 문제네.
   9. 아마 시간 변환을 할때 생기는 문제인듯..


[x]자꾸 저장된 시간이 아니라 드래그 된 시간만 보인다.
1. dragStop
2. uiState changed
3. show card
   1. show card. title=ㅊ, draggableStartMinutes=856, draggableEndMinutes=1199, startMinutes=855, endMinutes=1200
   2. 이게 문제네. startTime이 새로오면,  draggableStartMinutes도 갱신되야 하는거 아닌가?
   3. remember에 키를 전달했더니... 이젠 드래그가 실시간으로 안 먹네. ㅋㅋㅋㅋㅋ
   4. 원인은, state reset문제.
      1. 첫번째 드래그 시도에서는 잘 동작한다.
         1. 왜냐하면, 처음 remember로 초기화 되었고, 이후 드래그에 의해 값이 계속 갱신될것이다.
         2. 외부에서 startMinute가 바뀌면서, draggableStartMinutes가 다른 값이 됨.
         3. 하지만 드래그 콜백에선 이전 값을 기준으로 계산을 계속 하고 있음.(이건 컴포즈 안에 콜백을 쓰는데 컴포저블 함수 안의 요소를 쓸 경우 문제같다.)
         4. 그 후에 드래그를 아무리 시도해도, 새로운 key에 의해 타임슬롯에 저장된 startTime은 갱신되지 않음.
      5. 해결책은, 차라리 startMinutes 들의 remember키를 제거하고, 이걸 초기화 하는 LaunchEffect에 키를 줘서 초기화 하는 것이다.
      6. **근데 위의 과정이 어떻게 해도 지저분하니깐 사실, 인텐트가 폭주되더라도, 뷰모델에 이걸 전달해서 드래그하는 상태도 실시간으로 뷰모델의 상태를 갱신하게 만드는게 가장 좋을것 같다.**
4. update timeslot success
5. recieved routine composition
6. uiState changed.
7. 어..? 카드가 갱신이 안되는데..?

상태기반으로 슬롯을 그리는데, 드래그하여 자정을 넘기면 앱이 많이 느려짐.
[x] splite과정에서 뷰를 계속 만들어내는듯.

1. [x] 자정을 걸친 타음 슬롯의 처리.
   1. 이슈.
      1. 24:00은 00:00이다..때문에.. timeSlot을 23:00~00:00을 하게 될 경우, 예외가 발생.
   2. 해결.
      1. 애초에 잘못된 정의다. 수면시간은 자정을 넘겨서 타임슬롯을 설정할 수도 있다.
      2. end가 start보다 작으면 타임슬롯 카드를 두개 그림.
   3. 00:00 ~ end
   4. start ~ 24:00
      1. 즉 같은 타임슬롯의 카드뷰를 두개를 만들어야 하므로, 실질적인 EntityCardView와 DraggableCardView로 나눈다.